else
# Non-parametric (if selected)
{
ustar<-sample(utilde_1,n,replace=TRUE)
}
# Generate simulated dependent variable
ystar<-ustar
for (j in 1:(k-1)){
ystar<-ystar+X1[,j]*betatilde[[j]]
}
# Estimate Regression
# Under the alternative (H1): include all independent variables
h1est1star<-lm(ystar~X-1)
# Save summary
h1eststar_sum<-summary(h1est1star)
# Obtain value for test statistic
that_temp<-coef(h1eststar_sum)[,"t value"][[vtest+1]]
tstar[b]<-that_temp
}
# Calculate p-value for two-tailed test
pval=sum(rep(1,B)[abs(tstar)>abs(that)])/B
# Return a list with output items
list(regh1res=h1est_sum, that=that,tstar=tstar,pvalue=pval)
}
X<-matrix(c(Variables$TaxPersonalIncome,Variables$TaxRev,
Variables$TaxGoodsandServices,Variables$TaxCorporateProfits),4)
X<-cbind(1:1,X)
y<-matrix(Variables$LogGDP,1)
bootstrap1(y,X,2,B=10,prm=1)
bootstrap1<-function(y,X,vtest=2,B=99,prm=1){
# Perform hypothesis testing for a single variable (not a constant) using Bootstrapping
# Input:
# y: dependent variable
# X: matrix of independent variables (including constant if required)
# vtest: which independent/explanatory variable is to be tested for statistical significance
# B: number of Bootstrap replications
# prm: parametric (1) or non-parametric (0) bootstrap
# Output:
# A list that contains the following:
# (1) Regression output (actual data, under H1)
# (2) Value of the respective test statistic, based on actual data
# (3) Empirical distribution function based on boostrapping
# (4) Boostrap p-value
#---------------------------------------------------------------
# Preliminaries
n<-length(y) # Sample Size
k<-ncol(X) # Number of variables (including constant if present)
# Create matrix with variables, excluding the one to be tested for statistical significance
# (Required for Bootstrap DGP)
X1<-X[,-(vtest+1)]
# Estimate Regressions
# Under the alternative (H1): include all independent variables
h1est1<-lm(y~X-1)
# Save summary
h1est_sum<-summary(h1est1)
# Obtain value for test statistic
that<-coef(h1est_sum)[,"t value"][[vtest+1]]
# Under the null hypothesis (H0): exclude variable of interest
h0est1<-lm(y~X1-1)
# Save summary
h0est_sum<-summary(h0est1)
#Save residuals
utilde<-h0est1$residuals
# Create Efficient Residuals
utilde_1<-sqrt(n/(n-k-1))*(utilde-mean(utilde))
# Save coefficients (parameter estimates)
betatilde<-h0est1$coefficients
# Save Residuals Standard Error (estimate for the standard deviation of innovations)
sigmatilde<-h0est_sum$sigma
#----------------------------------------------------------------
# Boostrap Processs
# Create vector to store simulated test statistics
tstar<-rep(0,B)
for (b in 1:B){
# Generate dependent variable using the DGP under the null
# Get Innovations
# Parametric (if selected)
if (prm==1){
ustar<-sigmatilde*rnorm(n,0,1)
}
else
# Non-parametric (if selected)
{
ustar<-sample(utilde_1,n,replace=TRUE)
}
# Generate simulated dependent variable
ystar<-ustar
for (j in 1:(k-1)){
ystar<-ystar+X1[,j]*betatilde[[j]]
}
# Estimate Regression
# Under the alternative (H1): include all independent variables
h1est1star<-lm(ystar~X-1)
# Save summary
h1eststar_sum<-summary(h1est1star)
# Obtain value for test statistic
that_temp<-coef(h1eststar_sum)[,"t value"][[vtest+1]]
tstar[b]<-that_temp
}
# Calculate p-value for two-tailed test
pval=sum(rep(1,B)[abs(tstar)>abs(that)])/B
# Return a list with output items
list(regh1res=h1est_sum, that=that,tstar=tstar,pvalue=pval)
}
X<-matrix(c(OECDTaxREV$TaxPersonalIncome,OECDTaxREV$TaxRev,
OECDTaxREV$TaxGoodsandServices,OECDTaxREV$TaxCorporateProfits),4)
X<-cbind(1:1,X)
y<-matrix(OECDTaxREV$LogGDP,1)
bootstrap1(y,X,2,B=10,prm=1)
bootstrap1<-function(y,X,vtest=2,B=99,prm=1){
# Perform hypothesis testing for a single variable (not a constant) using Bootstrapping
# Input:
# y: dependent variable
# X: matrix of independent variables (including constant if required)
# vtest: which independent/explanatory variable is to be tested for statistical significance
# B: number of Bootstrap replications
# prm: parametric (1) or non-parametric (0) bootstrap
# Output:
# A list that contains the following:
# (1) Regression output (actual data, under H1)
# (2) Value of the respective test statistic, based on actual data
# (3) Empirical distribution function based on boostrapping
# (4) Boostrap p-value
#---------------------------------------------------------------
# Preliminaries
n<-length(y) # Sample Size
k<-ncol(X) # Number of variables (including constant if present)
# Create matrix with variables, excluding the one to be tested for statistical significance
# (Required for Bootstrap DGP)
X1<-X[,-(vtest+1)]
# Estimate Regressions
# Under the alternative (H1): include all independent variables
h1est1<-lm(y~X-1)
# Save summary
h1est_sum<-summary(h1est1)
# Obtain value for test statistic
that<-coef(h1est_sum)[,"t value"][[vtest+1]]
# Under the null hypothesis (H0): exclude variable of interest
h0est1<-lm(y~X1-1)
# Save summary
h0est_sum<-summary(h0est1)
#Save residuals
utilde<-h0est1$residuals
# Create Efficient Residuals
utilde_1<-sqrt(n/(n-k-1))*(utilde-mean(utilde))
# Save coefficients (parameter estimates)
betatilde<-h0est1$coefficients
# Save Residuals Standard Error (estimate for the standard deviation of innovations)
sigmatilde<-h0est_sum$sigma
#----------------------------------------------------------------
# Boostrap Processs
# Create vector to store simulated test statistics
tstar<-rep(0,B)
for (b in 1:B){
# Generate dependent variable using the DGP under the null
# Get Innovations
# Parametric (if selected)
if (prm==1){
ustar<-sigmatilde*rnorm(n,0,1)
}
else
# Non-parametric (if selected)
{
ustar<-sample(utilde_1,n,replace=TRUE)
}
# Generate simulated dependent variable
ystar<-ustar
for (j in 1:(k-1)){
ystar<-ystar+X1[,j]*betatilde[[j]]
}
# Estimate Regression
# Under the alternative (H1): include all independent variables
h1est1star<-lm(ystar~X-1)
# Save summary
h1eststar_sum<-summary(h1est1star)
# Obtain value for test statistic
that_temp<-coef(h1eststar_sum)[,"t value"][[vtest+1]]
tstar[b]<-that_temp
}
# Calculate p-value for two-tailed test
pval=sum(rep(1,B)[abs(tstar)>abs(that)])/B
# Return a list with output items
list(regh1res=h1est_sum, that=that,tstar=tstar,pvalue=pval)
}
X<-matrix(c(OECDTaxREV$TaxPersonalIncome,OECDTaxREV$TaxRev,
OECDTaxREV$TaxGoodsandServices,OECDTaxREV$TaxCorporateProfits),4)
X<-cbind(1:1,X)
y<-matrix(OECDTaxREV$GDP,1)
bootstrap1(y,X,2,B=10,prm=1)
library(readxl)
Variables <- read_excel("G:/mahmood/DAL/Econometrics II/Bootstraps/Variables.xlsx")
View(Variables)
bootstrap1<-function(y,X,vtest=2,B=99,prm=1){
# Perform hypothesis testing for a single variable (not a constant) using Bootstrapping
# Input:
# y: dependent variable
# X: matrix of independent variables (including constant if required)
# vtest: which independent/explanatory variable is to be tested for statistical significance
# B: number of Bootstrap replications
# prm: parametric (1) or non-parametric (0) bootstrap
# Output:
# A list that contains the following:
# (1) Regression output (actual data, under H1)
# (2) Value of the respective test statistic, based on actual data
# (3) Empirical distribution function based on boostrapping
# (4) Boostrap p-value
#---------------------------------------------------------------
# Preliminaries
n<-length(y) # Sample Size
k<-ncol(X) # Number of variables (including constant if present)
# Create matrix with variables, excluding the one to be tested for statistical significance
# (Required for Bootstrap DGP)
X1<-X[,-(vtest+1)]
# Estimate Regressions
# Under the alternative (H1): include all independent variables
h1est1<-lm(y~X-1)
# Save summary
h1est_sum<-summary(h1est1)
# Obtain value for test statistic
that<-coef(h1est_sum)[,"t value"][[vtest+1]]
# Under the null hypothesis (H0): exclude variable of interest
h0est1<-lm(y~X1-1)
# Save summary
h0est_sum<-summary(h0est1)
#Save residuals
utilde<-h0est1$residuals
# Create Efficient Residuals
utilde_1<-sqrt(n/(n-k-1))*(utilde-mean(utilde))
# Save coefficients (parameter estimates)
betatilde<-h0est1$coefficients
# Save Residuals Standard Error (estimate for the standard deviation of innovations)
sigmatilde<-h0est_sum$sigma
#----------------------------------------------------------------
# Boostrap Processs
# Create vector to store simulated test statistics
tstar<-rep(0,B)
for (b in 1:B){
# Generate dependent variable using the DGP under the null
# Get Innovations
# Parametric (if selected)
if (prm==1){
ustar<-sigmatilde*rnorm(n,0,1)
}
else
# Non-parametric (if selected)
{
ustar<-sample(utilde_1,n,replace=TRUE)
}
# Generate simulated dependent variable
ystar<-ustar
for (j in 1:(k-1)){
ystar<-ystar+X1[,j]*betatilde[[j]]
}
# Estimate Regression
# Under the alternative (H1): include all independent variables
h1est1star<-lm(ystar~X-1)
# Save summary
h1eststar_sum<-summary(h1est1star)
# Obtain value for test statistic
that_temp<-coef(h1eststar_sum)[,"t value"][[vtest+1]]
tstar[b]<-that_temp
}
# Calculate p-value for two-tailed test
pval=sum(rep(1,B)[abs(tstar)>abs(that)])/B
# Return a list with output items
list(regh1res=h1est_sum, that=that,tstar=tstar,pvalue=pval)
}
X<-matrix(c(Variables$dlgdp,Variables$dlypd,Variables$dlhpi,Variables$dldj),,4)
X<-cbind(1:1,X)
y<-matrix(Variables$dlcc,,1)
bootstrap1(y,X,2,B=999,prm=1)
blogdown::new_post("Hypothesis Testing Using Bootstrap in R")
blogdown::serve_site()
blogdown::build_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::new_post("Plots with Software Tableau")
blogdown::serve_site()
blogdown::build_site()
options(blogdown.ext = '.Rmd', blogdown.author = 'Mahmood Hasan')
blogdown::new_post("Plots with Software Tableau")
blogdown::serve_site()
```{r, echo=FALSE,out.width="70%", out.height="40%",fig.cap="Number of Installations Vs Installations Cost ",fig.show='hold',fig.align='center'}
blogdown::build_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
options(blogdown.ext = '.Rmd', blogdown.author = 'Mahmood Hasan')
blogdown::new_post("Knowledge Mobilization")
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::build_site()
options(blogdown.ext = '.Rmd', blogdown.author = 'Mahmood Hasan')
blogdown::build_site()
blogdown::serve_site()
options(blogdown.ext = '.Rmd', blogdown.author = 'Mahmood Hasan')
blogdown::new_post("Machine Learning: Support Vector Machines")
blogdown::serve_site()
blogdown::serve_site()
servr::daemon_stop
blogdown::serve_site()
blogdown::build_site()
View(OECDTaxREV)
A<-subset(OECDTaxREV, LOCATION = AUS)
View(A)
A<-subset(OECDTaxREV, LOCATION = "AUS")
A<-subset(OECDTaxREV, LOCATION == "AUS")
newdata <- subset(OECDTaxREV, LOCATION == c(("AUS", "CAN", "GER","ITA", "MEX",
"DNK", "TUR", "IRL", "FRA", "JPN")
newdata <- subset(OECDTaxREV, LOCATION == c(("AUS", "CAN", "GER","ITA", "MEX",
"DNK", "TUR", "IRL", "FRA", "JPN"))
newdata <- subset(OECDTaxREV, LOCATION == c("AUS", "CAN", "GER","ITA", "MEX",
"DNK", "TUR", "IRL", "FRA", "JPN")
)
View(newdata)
View(OECDTaxREV)
newdata <- subset(OECDTaxREV, LOCATION == c("AUS","CAN", "GER","ITA", "MEX",
"DNK", "TUR","IRL","FRA","JPN"))
View(Aniplot)
View(newdata)
newdata<-OECDTaxREV[OECDTaxREV$Location ==c("AUS","CAN", "GER","ITA", "MEX",
"DNK", "TUR","IRL","FRA","JPN"),]
newdata<-OECDTaxREV[OECDTaxREV$LOCATION ==c("AUS","CAN", "GER","ITA", "MEX",
"DNK", "TUR","IRL","FRA","JPN"),]
View(newdata)
newdata<-OECDTaxREV[OECDTaxREV$LOCATION ==c("AUS","CAN", "GER","ITA", "MEX",
"DNK", "TUR","IRL","FRA","JPN"), ]
View(newdata)
View(OECDTaxREV)
newdata<-OECDTaxREV[OECDTaxREV$Continent == "Europe", ]
View(newdata)
rm(A)
newdata<-OECDTaxREV[OECDTaxREV$Continent == "Europe" &OECDTaxREV$LOCATION == "CAN", ]
View(newdata)
newdata<-OECDTaxREV[OECDTaxREV$Continent == "Europe" & OECDTaxREV$LOCATION == "CAN", ]
View(newdata)
newdata<-OECDTaxREV[OECDTaxREV$Continent == "Europe" | OECDTaxREV$LOCATION == "CAN", ]
View(newdata)
View(newdata)
View(p1)
blogdown::serve_site()
servr::daemon_stop
blogdown::serve_site()
WindCost <- WindCostVsLCOE %>%
ggplot(aes(x = Capacityfactor, y=IntalledCost, size = LCOE,
color=Continent)) +
geom_point(alpha = 0.7, stroke =0) +
theme_fivethirtyeight()+
scale_size(range = c(2, 12), guide = "none") +
scale_x_log10() +
labs(title = "Wind Power Installation Cost Vs Capacity Factor",
x = "Capacity Factor (%)", y = "Installation Cost (USD/KWatt)",
caption = "Animation Plot")+
theme(axis.title = element_text(),
text = element_text(family = "Rubik"),
legend.text = element_text(size=12))+
scale_color_brewer(palette="Set1")+
transition_time(as.integer(Solar_CapacityVsLCOE$Year))+ #as.integer to remove decimal from Year
labs(subtitle = "Year:{frame_time}")+
shadow_wake(wake_length = 0.1) #to add wave to plot
animate(WindCost, renderer = gifski_renderer(),  #to animate the plot
duration = 30, end_pause = 60)
library("gapminder")
library("ggplot2")
library("gganimate")
library("ggthemes")
library("dplyr")
library("png")
library("gifski")
WindCost <- WindCostVsLCOE %>%
ggplot(aes(x = Capacityfactor, y=IntalledCost, size = LCOE,
color=Continent)) +
geom_point(alpha = 0.7, stroke =0) +
theme_fivethirtyeight()+
scale_size(range = c(2, 12), guide = "none") +
scale_x_log10() +
labs(title = "Wind Power Installation Cost Vs Capacity Factor",
x = "Capacity Factor (%)", y = "Installation Cost (USD/KWatt)",
caption = "Animation Plot")+
theme(axis.title = element_text(),
text = element_text(family = "Rubik"),
legend.text = element_text(size=12))+
scale_color_brewer(palette="Set1")+
transition_time(as.integer(Solar_CapacityVsLCOE$Year))+ #as.integer to remove decimal from Year
labs(subtitle = "Year:{frame_time}")+
shadow_wake(wake_length = 0.1) #to add wave to plot
animate(WindCost, renderer = gifski_renderer(),  #to animate the plot
duration = 30, end_pause = 60)
##Save as gif
WindCost <- WindCostVsLCOE %>%
ggplot(aes(x = Capacityfactor, y=IntalledCost, size = LCOE,
color=Continent)) +
geom_point(alpha = 0.7, stroke =0) +
theme_fivethirtyeight()+
scale_size(range = c(2, 12), guide = "none") +
scale_x_log10() +
labs(title = "Wind Power Installation Cost Vs Capacity Factor",
x = "Capacity Factor (%)", y = "Installation Cost (USD/KWatt)",
caption = "Animation Plot")+
theme(axis.title = element_text(),
text = element_text(family = "Rubik"),
legend.text = element_text(size=12))+
scale_color_brewer(palette="Set1")+
transition_time(as.integer(Solar_CapacityVsLCOE$Year))+ #as.integer to remove decimal from Year
labs(subtitle = "Year:{frame_time}")+
shadow_wake(wake_length = 0.1) #to add wave to plot
library(readxl)
WindCostVsLCOE <- read_excel("D:/Website/Data/Wind_CapacityVsLCOE.xlsx",
sheet = "OnShoreWind (2)")
library("gapminder")
library("ggplot2")
library("gganimate")
library("ggthemes")
library("dplyr")
library("png")
library("gifski")
WindCost <- WindCostVsLCOE %>%
ggplot(aes(x = Capacityfactor, y=IntalledCost, size = LCOE,
color=Continent)) +
geom_point(alpha = 0.7, stroke =0) +
theme_fivethirtyeight()+
scale_size(range = c(2, 12), guide = "none") +
scale_x_log10() +
labs(title = "Wind Power Installation Cost Vs Capacity Factor",
x = "Capacity Factor (%)", y = "Installation Cost (USD/KWatt)",
caption = "Animation Plot")+
theme(axis.title = element_text(),
text = element_text(family = "Rubik"),
legend.text = element_text(size=12))+
scale_color_brewer(palette="Set1")+
transition_time(as.integer(Solar_CapacityVsLCOE$Year))+ #as.integer to remove decimal from Year
labs(subtitle = "Year:{frame_time}")+
shadow_wake(wake_length = 0.1) #to add wave to plot
animate(WindCost, renderer = gifski_renderer(),  #to animate the plot
duration = 30, end_pause = 60)
animate(WindCost, renderer = gifski_renderer(),  #to animate the plot
duration = 30, end_pause = 60)
blogdown::serve_site()
library(readxl)
WindCostVsLCOE <- read_excel("D:/Website/Data/Wind_CapacityVsLCOE.xlsx",
sheet = "OnShoreWind (2)")
library("gapminder")
library("ggplot2")
library("gganimate")
library("ggthemes")
library("dplyr")
library("png")
library("gifski")
WindCost <- WindCostVsLCOE %>%
ggplot(aes(x = Capacityfactor, y=IntalledCost, size = LCOE,
color=Continent)) +
geom_point(alpha = 0.7, stroke =0) +
theme_fivethirtyeight()+
scale_size(range = c(2, 12), guide = "none") +
scale_x_log10() +
labs(title = "Wind Power Installation Cost Vs Capacity Factor",
x = "Capacity Factor (%)", y = "Installation Cost (USD/KWatt)",
caption = "Animation Plot")+
theme(axis.title = element_text(),
text = element_text(family = "Rubik"),
legend.text = element_text(size=12))+
scale_color_brewer(palette="Set1")+
transition_time(as.integer(Solar_CapacityVsLCOE$Year))+ #as.integer to remove decimal from Year
labs(subtitle = "Year:{frame_time}")+
shadow_wake(wake_length = 0.1) #to add wave to plot
animate(WindCost, renderer = gifski_renderer(),  #to animate the plot
duration = 30, end_pause = 60)
animate(WindCost, renderer = gifski_renderer(),  #to animate the plot
duration = 30, end_pause = 60)
##Save as gif
anim_save("wind_CostF.gif")
servr::daemon_stop
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
WindCost <- WindCostVsLCOE %>%
ggplot(aes(x = Capacityfactor, y=IntalledCost, size = LCOE,
color=Continent)) +
geom_point(alpha = 0.7, stroke =0) +
theme_fivethirtyeight()+
scale_size(range = c(2, 12), guide = "none") +
scale_x_log10() +
labs(title = "Wind Power Cost Vs Capacity Factor",
x = "Capacity Factor (%)", y = "Installation Cost (USD/KWatt)",
caption = "Animation Plot")+
theme(axis.title = element_text(),
text = element_text(family = "Rubik"),
legend.text = element_text(size=12))+
scale_color_brewer(palette="Set1")+
transition_time(as.integer(WindCostVsLCOE$Year))+ #as.integer to remove decimal from Year
labs(subtitle = "Year:{frame_time}")+
shadow_wake(wake_length = 0.1) #to add wave to plot
animate(WindCost, renderer = gifski_renderer(),  #to animate the plot
duration = 30, end_pause = 60)
##Save as gif
anim_save("wind_CostF.gif")
blogdown::serve_site()
servr::daemon_stop
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::build_site()
